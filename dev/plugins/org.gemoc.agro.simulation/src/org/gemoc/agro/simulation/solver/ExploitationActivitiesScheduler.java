package org.gemoc.agro.simulation.solver;

import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.gemoc.agro.ActivitiesDSLStandaloneSetup;
import org.gemoc.agro.activitiesDSL.ActivitiesDSLPackage;
import org.gemoc.agro.activitiesDSL.ActivityResource;
import org.gemoc.agro.activitiesDSL.Culture;
import org.gemoc.agro.activitiesDSL.Date;
import org.gemoc.agro.activitiesDSL.ExploitationActivity;
import org.gemoc.agro.exploitation.Surface;
import org.gemoc.agro.simulation.ActivityWork;
import org.gemoc.agro.simulation.ClimateData;
import org.gemoc.agro.simulation.Day;
import org.gemoc.agro.simulation.ResourceAllocation;
import org.gemoc.agro.simulation.Schedule;
import org.gemoc.agro.simulation.SchedulingFeedback;
import org.gemoc.agro.simulation.SimulationFactory;
import org.gemoc.agro.simulation.SimulationPackage;
import org.optaplanner.core.api.solver.Solver;
import org.optaplanner.core.api.solver.SolverFactory;
import org.optaplanner.core.config.constructionheuristic.ConstructionHeuristicPhaseConfig;
import org.optaplanner.core.config.constructionheuristic.placer.EntityPlacerConfig;
import org.optaplanner.core.config.constructionheuristic.placer.QueuedEntityPlacerConfig;
import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;
import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;
import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;
import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;
import org.optaplanner.core.config.localsearch.LocalSearchPhaseConfig;
import org.optaplanner.core.config.localsearch.decider.acceptor.AcceptorConfig;
import org.optaplanner.core.config.localsearch.decider.forager.LocalSearchForagerConfig;
import org.optaplanner.core.config.phase.PhaseConfig;
import org.optaplanner.core.config.score.definition.ScoreDefinitionType;
import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;
import org.optaplanner.core.config.solver.SolverConfig;
import org.optaplanner.core.config.solver.termination.TerminationConfig;

import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;

public class ExploitationActivitiesScheduler {

	public void createSchedule(Schedule s) {
		createWorkToDo(s);
		createResourceAllocations(s);

		// SolverConfig conf = configureSolver(s);
		// Solver solver = conf.buildSolver();
		// //
		SolverFactory solverFactory = SolverFactory
				.createFromXmlResource("org/gemoc/agro/simulation/solver/config.xml");

		solverFactory
				.getSolverConfig()
				.getTerminationConfig()
				.setSecondsSpentLimit(
						new Long(s.getSolverSearchSecondsSpentLimit()));
		Solver solver = solverFactory.buildSolver();

		SimulationSolution unsolvedCloudBalance = new SimulationSolution(s);

		// Solve the problem
		solver.solve(unsolvedCloudBalance);
		SimulationSolution solvedCloudBalance = (SimulationSolution) solver
				.getBestSolution();
		s.getWorkToDo().clear();
		s.getWorkToDo()
				.addAll(solvedCloudBalance.getSimulation().getWorkToDo());
		s.getAllocations().clear();
		s.getAllocations().addAll(
				solvedCloudBalance.getSimulation().getAllocations());

		s.setHardScore(solvedCloudBalance.getSimulation().getHardScore());
		s.setSoftScore(solvedCloudBalance.getSimulation().getSoftScore());
		new AgroScoreCalculator().calculateScore(unsolvedCloudBalance);

	}

	private void createResourceAllocations(Schedule s) {
		s.getAllocations().clear();
		for (ActivityWork w : s.getWorkToDo()) {
			if (w.getActivity() != null) {
				for (ActivityResource use : w.getActivity().getUses()) {
					if (use.getResourceKind() != null) {
						for (int i = 0; i < use.getQuantity(); i++) {
							ResourceAllocation res = SimulationFactory.eINSTANCE
									.createResourceAllocation();
							res.setKind(use.getResourceKind());
							res.setWork(w);
							s.getAllocations().add(res);
						}

					}
				}
			}

		}

	}

	public static void main(String[] args) {

		ResourceSet set = new ResourceSetImpl();

		set.getPackageRegistry().put(SimulationPackage.eINSTANCE.getNsURI(),
				SimulationPackage.eINSTANCE);
		set.getPackageRegistry().put(ActivitiesDSLPackage.eINSTANCE.getNsURI(),
				ActivitiesDSLPackage.eINSTANCE);
		set.getResourceFactoryRegistry().getExtensionToFactoryMap()
				.put("simulation", new XMIResourceFactoryImpl());
		set.getResourceFactoryRegistry().getExtensionToFactoryMap()
				.put("exploitation", new XMIResourceFactoryImpl());

		new ActivitiesDSLStandaloneSetup().createInjectorAndDoEMFRegistration();

		Resource loaded = set
				.getResource(
						URI.createFileURI("/home/cedric/src/farmingmodeling/dev/workspace_projects/MyExploitation/schedule.simulation"),
						true);
		EcoreUtil.resolveAll(loaded);
		for (Schedule s : Iterables
				.filter(loaded.getContents(), Schedule.class)) {
			new ExploitationActivitiesScheduler().createSchedule(s);
			Iterator<SchedulingFeedback> it = Iterators.filter(
					s.eAllContents(), SchedulingFeedback.class);
			while (it.hasNext()) {
				SchedulingFeedback feedback = it.next();
				System.out.println(feedback.getLevel() + " : "
						+ feedback.getMessage());
			}
		}
		System.out.println("ExploitationActivitiesScheduler.main()");
	}

	private static SolverConfig configureSolver(Schedule s) {
		SolverConfig conf = new SolverConfig();
		conf.setSolutionClass(SimulationSolution.class);

		conf.setEntityClassList(Lists.newArrayList(ActivityWork.class,
				ResourceAllocation.class));

		ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();
		scoreDirectorFactoryConfig
				.setScoreDefinitionType(ScoreDefinitionType.HARD_SOFT);
		scoreDirectorFactoryConfig
				.setEasyScoreCalculatorClass(AgroScoreCalculator.class);
		scoreDirectorFactoryConfig.setInitializingScoreTrend("ONLY_DOWN");
		conf.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);

		TerminationConfig terminationConfig = new TerminationConfig();
		terminationConfig.setSecondsSpentLimit(new Long(s
				.getSolverSearchSecondsSpentLimit()));
		conf.setTerminationConfig(terminationConfig);

		List<PhaseConfig> phases = Lists.newArrayList();
		ConstructionHeuristicPhaseConfig heuristicForActivities = new ConstructionHeuristicPhaseConfig();
		// heuristic
		// .setConstructionHeuristicType(ConstructionHeuristicType.FIRST_FIT_DECREASING);

		heuristicForActivities.setEntityPlacerConfig(createPlacerConfig());
		phases.add(heuristicForActivities);

		LocalSearchPhaseConfig localsearch = new LocalSearchPhaseConfig();
		AcceptorConfig acceptorConfig = new AcceptorConfig();
		acceptorConfig.setEntityTabuSize(7);

		ChangeMoveSelectorConfig cmSelec = new ChangeMoveSelectorConfig();
		cmSelec.setEntitySelectorConfig(createActivitiesSelector());
		localsearch.setMoveSelectorConfig(cmSelec);

		localsearch.setAcceptorConfig(acceptorConfig);

		LocalSearchForagerConfig foragerConfig = new LocalSearchForagerConfig();
		foragerConfig.setAcceptedCountLimit(1000);
		localsearch.setForagerConfig(foragerConfig);
		phases.add(localsearch);
		conf.setPhaseConfigList(phases);
		return conf;
	}

	private static EntityPlacerConfig createPlacerConfig() {

		QueuedEntityPlacerConfig queue = new QueuedEntityPlacerConfig();
		// EntitySelectorConfig activitiesSelector = createActivitiesSelector();
		// queue.setEntitySelectorConfig(activitiesSelector);

		queue.setEntitySelectorConfig(createActivitiesSelector());

		List<MoveSelectorConfig> moveSelectorConfigList = Lists.newArrayList();
		ChangeMoveSelectorConfig cmSelec = new ChangeMoveSelectorConfig();
		cmSelec.setEntitySelectorConfig(createActivitiesSelector());
		moveSelectorConfigList.add(cmSelec);

		EntitySelectorConfig resAlloc = createResourceSelector();
		ChangeMoveSelectorConfig cmSelecRes = new ChangeMoveSelectorConfig();
		cmSelecRes.setEntitySelectorConfig(resAlloc);
		moveSelectorConfigList.add(cmSelecRes);
		queue.setMoveSelectorConfigList(moveSelectorConfigList);

		// queue.setEntitySelectorConfig(createResourceSelector());
		return queue;
	}

	private static EntitySelectorConfig createResourceSelector() {
		EntitySelectorConfig resAlloc = new EntitySelectorConfig();
		resAlloc.setEntityClass(ResourceAllocation.class);
		resAlloc.setCacheType(SelectionCacheType.PHASE);
		return resAlloc;
	}

	private static EntitySelectorConfig createActivitiesSelector() {
		EntitySelectorConfig activitiesSelector = new EntitySelectorConfig();
		activitiesSelector.setEntityClass(ActivityWork.class);
		activitiesSelector.setCacheType(SelectionCacheType.PHASE);
		return activitiesSelector;
	}

	public void createWorkToDo(Schedule sim) {
		sim.getWorkToDo().clear();
		/*
		 * for each surface x culture we declare the corresponding activities
		 */
		if (sim.getExploitation() != null) {
			for (Surface s : sim.getExploitation().getSurfaces()) {
				if (s.getDedicatedto() != null) {
					for (Culture c : s.getDedicatedto().getCultures()) {
						for (ExploitationActivity activity : c.getActivities()) {
							ActivityWork work = SimulationFactory.eINSTANCE
									.createActivityWork();
							work.setActivity(activity);
							if (activity.getStartDate() != null) {
								Date startDate = activity.getStartDate();
								Day correspondingDay = getCorrespondingDay(
										sim.getClimateData(), startDate);
								if (correspondingDay != null) {
									work.setScheduledOn(correspondingDay);
								}
							}
							work.setOnSurface(s);
							sim.getWorkToDo().add(work);
						}

					}
				}
			}
		}
	}

	private Day getCorrespondingDay(ClimateData climateData, Date startDate) {
		Iterator<Day> it = climateData.getDays().iterator();
		while (it.hasNext()) {
			Day day = it.next();
			if (startDate.getMonth() == day.getMonth()
					&& startDate.getDay() == day.getDay()) {
				return day;
			}
		}
		return null;
	}

}
